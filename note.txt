*单页应用的问题：
1.seo不友好
2.首屏时间较长，用户体验差

解决方案：服务器端渲染


*前端技术选型

1.单页
2.多页

多页应用其实最主要的就是进行一些dom操作  工程化工具：grunt、gulp 但是这两个工具命令注册功能都可以被npm script替代掉了
多页应用模块化seajs,requirejs  静态资源使用gulp,grunt编译到html中，自由度低，操作复杂

多页所有内容都在前端js生产，js承担更多业务逻辑，后端只提供API，页面路由跳转在前端控制,静态文件处理只需在js文件中引用
并且交由模块化工具转化为线上可用的静态资源，并且可以定制化转化过程适应不同的需求场景

其他技术选型考虑因素：
1.浏览器兼容  2.toB还是toC  3.移动端还是pc端

工程架构最重要的一点是：定制  因为每一个项目都会有它特有的需求

*工程架构和项目架构

工程架构更多考虑的是让项目良好的运行,更方便开发，自动化
项目架构更多考虑的是业务处理，功能开发，扩展性   包括：技术选型,数据解决方案,代码风格

*web常用网络优化
1.合并资源文件，减少HTTP请求
2.压缩资源文件
3.利用缓存机制，尽可能使用缓存减少请求  现在最流行的缓存机制，是根据文件内容计算得到一个hash值拼接到文件名上，如果文件内容不变hash值也不会变

webpack中publicPath在引用资源文件路径时会用到，publicPath会加在文件名前面作为引用路径

*webpack配置
babel-loader只是插件，还需安装babel-core才能让babel-loader生效

如果js或jsx文件中有jsx代码，那就必须 import React from 'react'  因为jsx中每一个html标签，都调用了React.CreateElement()转化为js对象

*Babel 6 的 loose mode
 loose mode 在babel中通常是不推荐使用的，但是我们需要知道的是使用 loose mode 转换而来的代码更加像ES5的代码（更像是人手写的）
大多数Babel插件都有两种模式 normal mode 和 loose mode

*搭建webpack工程流程：

1.配置entry
2.配置output
3.配置module rules
4.配置babel-loader

回调函数才用 =>声明

redux与mobx:
redux每次执行action会返回新的state，所有页面从新渲染，但是react虚拟dom存在，所以效率依旧高;mobx则始终只有一份数据，每次更新只是修改
数据对象，然后更新依赖该数据的视图。从效率上讲，肯定mobx会更高
redux中有action，reducer这些概念第一是遵循flux的定义，第二是可以有办法清晰的记录程序执行的action及相应state改变 ,更好的debug。所以
redux有一套严格的模式，而mobx简单没有这么多概念

代码隔行：可以归为一类，或者处理同一件事的代码不隔行，*按处理步骤，不同步骤要隔*;function return要隔行;作用域顶部变量声明要;
			模块顶部import要;function定义上下留空行;语句的{}中基本上就不隔;fn{}中的代码不多可以少隔(变量声明后不隔)，尽量考虑不同步骤隔;在一个module最外层
			一个步骤的变量声明与后面的语句或函数调用不隔;在{}中没有分步骤，只有多个语句或复杂函数调用可以隔;
			module外层fn定义,fn执行,语句之间如果不是在处理同一问题，要隔

配置相关的变量声明和初始化比较重要的，含有全局性质的变量，习惯性放到顶部;如果obj...比较长考虑解构;		





